#if justAsCutAndPastSource__CanBeDonePerClassAlsoWith__javah

/* DO NOT EDIT THIS FILE it is machine generated */
#include <jni.h>
/* Header for all classes */
#ifndef _Included_allClasses
#define _Included_allClasses
#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////


/*
 * Class:     haiku.avr.lib.arduino.HaikuMicroKernelProcessing
 * Method:    init
 * Signature: ()V
 */
JNIEXPORT void Java_haiku_avr_lib_arduino_HaikuMicroKernelProcessing_init
  (JNIEnv *, jclass);

JNIEXPORT void Java_haiku_avr_lib_arduino_HaikuMicroKernelProcessing_init
  (JNIEnv *env, jclass obj)
{
    // TODO: insert your code here
}

/*
 * Proprietary HaikuVM stack to JNI interface function.
 * DO NOT EDIT THIS FUNCTION – it is machine generated.
 * 
 * Class:     haiku.avr.lib.arduino.HaikuMicroKernelProcessing
 * Method:    init
 * Signature: ()V
 */
JNIEXPORT void native_haiku_avr_lib_arduino_HaikuMicroKernelProcessing_init_V(void) {
    pushTop();    // Save variable top onto stack.
    {
        jclass     obj = NULL;
        JNIEnv     *env = NULL; // not used in HaikuVM
        Java_haiku_avr_lib_arduino_HaikuMicroKernelProcessing_init(env, obj);
    }
    popTop();
}

/////////////////////////////////////////////////


/*
 * Class:     java.lang.Thread
 * Method:    setStateAndSwitch
 * Signature: (I)I
 */
JNIEXPORT jint Java_java_lang_Thread_setStateAndSwitch
  (JNIEnv *, jobject, jint);

JNIEXPORT jint Java_java_lang_Thread_setStateAndSwitch
  (JNIEnv *env, jobject obj, jint arg1)
{
    // TODO: insert your code here
    return 0;
}

/*
 * Proprietary HaikuVM stack to JNI interface function.
 * DO NOT EDIT THIS FUNCTION – it is machine generated.
 * 
 * Class:     java.lang.Thread
 * Method:    setStateAndSwitch
 * Signature: (I)I
 */
JNIEXPORT void native_java_lang_Thread_setStateAndSwitch_II(void) {
    pushTop();    // Save variable top onto stack.
    {
        jint    arg1 = pop()->i;
        jobject    obj = pop()->a;
        JNIEnv     *env = NULL; // not used in HaikuVM
        top.s1.i = Java_java_lang_Thread_setStateAndSwitch(env, obj, arg1);
    }
    // Variable top holds the return value.
}

/////////////////////////////////////////////////


/*
 * Class:     processing.hardware.arduino.cores.arduino.HardwareSerialImpl
 * Method:    write
 * Signature: (B)B
 */
JNIEXPORT jbyte Java_processing_hardware_arduino_cores_arduino_HardwareSerialImpl_write
  (JNIEnv *, jclass, jbyte);

JNIEXPORT jbyte Java_processing_hardware_arduino_cores_arduino_HardwareSerialImpl_write
  (JNIEnv *env, jclass obj, jbyte arg1)
{
    // TODO: insert your code here
    return 0;
}

/*
 * Proprietary HaikuVM stack to JNI interface function.
 * DO NOT EDIT THIS FUNCTION – it is machine generated.
 * 
 * Class:     processing.hardware.arduino.cores.arduino.HardwareSerialImpl
 * Method:    write
 * Signature: (B)B
 */
JNIEXPORT void native_processing_hardware_arduino_cores_arduino_HardwareSerialImpl_write_BB(void) {
    pushTop();    // Save variable top onto stack.
    {
        jbyte    arg1 = pop()->b;
        jclass     obj = NULL;
        JNIEnv     *env = NULL; // not used in HaikuVM
        top.s1.b = Java_processing_hardware_arduino_cores_arduino_HardwareSerialImpl_write(env, obj, arg1);
    }
    // Variable top holds the return value.
}

/////////////////////////////////////////////////


/*
 * Class:     processing.hardware.arduino.cores.arduino.ArduinoImpl
 * Method:    pinMode
 * Signature: (BB)V
 */
JNIEXPORT void Java_processing_hardware_arduino_cores_arduino_ArduinoImpl_pinMode
  (JNIEnv *, jclass, jbyte, jbyte);

JNIEXPORT void Java_processing_hardware_arduino_cores_arduino_ArduinoImpl_pinMode
  (JNIEnv *env, jclass obj, jbyte arg1, jbyte arg2)
{
    // TODO: insert your code here
}

/*
 * Proprietary HaikuVM stack to JNI interface function.
 * DO NOT EDIT THIS FUNCTION – it is machine generated.
 * 
 * Class:     processing.hardware.arduino.cores.arduino.ArduinoImpl
 * Method:    pinMode
 * Signature: (BB)V
 */
JNIEXPORT void native_processing_hardware_arduino_cores_arduino_ArduinoImpl_pinMode_BBV(void) {
    pushTop();    // Save variable top onto stack.
    {
        jbyte    arg2 = pop()->b;
        jbyte    arg1 = pop()->b;
        jclass     obj = NULL;
        JNIEnv     *env = NULL; // not used in HaikuVM
        Java_processing_hardware_arduino_cores_arduino_ArduinoImpl_pinMode(env, obj, arg1, arg2);
    }
    popTop();
}

/////////////////////////////////////////////////


/*
 * Class:     processing.hardware.arduino.cores.arduino.ArduinoImpl
 * Method:    digitalWrite
 * Signature: (BB)V
 */
JNIEXPORT void Java_processing_hardware_arduino_cores_arduino_ArduinoImpl_digitalWrite
  (JNIEnv *, jclass, jbyte, jbyte);

JNIEXPORT void Java_processing_hardware_arduino_cores_arduino_ArduinoImpl_digitalWrite
  (JNIEnv *env, jclass obj, jbyte arg1, jbyte arg2)
{
    // TODO: insert your code here
}

/*
 * Proprietary HaikuVM stack to JNI interface function.
 * DO NOT EDIT THIS FUNCTION – it is machine generated.
 * 
 * Class:     processing.hardware.arduino.cores.arduino.ArduinoImpl
 * Method:    digitalWrite
 * Signature: (BB)V
 */
JNIEXPORT void native_processing_hardware_arduino_cores_arduino_ArduinoImpl_digitalWrite_BBV(void) {
    pushTop();    // Save variable top onto stack.
    {
        jbyte    arg2 = pop()->b;
        jbyte    arg1 = pop()->b;
        jclass     obj = NULL;
        JNIEnv     *env = NULL; // not used in HaikuVM
        Java_processing_hardware_arduino_cores_arduino_ArduinoImpl_digitalWrite(env, obj, arg1, arg2);
    }
    popTop();
}

/////////////////////////////////////////////////


/*
 * Class:     processing.hardware.arduino.cores.arduino.ArduinoImpl
 * Method:    millis
 * Signature: ()J
 */
JNIEXPORT jlong Java_processing_hardware_arduino_cores_arduino_ArduinoImpl_millis
  (JNIEnv *, jclass);

JNIEXPORT jlong Java_processing_hardware_arduino_cores_arduino_ArduinoImpl_millis
  (JNIEnv *env, jclass obj)
{
    // TODO: insert your code here
    return 0;
}

/*
 * Proprietary HaikuVM stack to JNI interface function.
 * DO NOT EDIT THIS FUNCTION – it is machine generated.
 * 
 * Class:     processing.hardware.arduino.cores.arduino.ArduinoImpl
 * Method:    millis
 * Signature: ()J
 */
JNIEXPORT void native_processing_hardware_arduino_cores_arduino_ArduinoImpl_millis_J(void) {
    pushTop();    // Save variable top onto stack.
    {
        jclass     obj = NULL;
        JNIEnv     *env = NULL; // not used in HaikuVM
        top.j = Java_processing_hardware_arduino_cores_arduino_ArduinoImpl_millis(env, obj);
    }
    // Variable top holds the return value. But we have to push the lower half.
    pushTop0();
}

/////////////////////////////////////////////////


/*
 * Class:     processing.hardware.arduino.cores.arduino.ArduinoImpl
 * Method:    delayMicroseconds
 * Signature: (I)V
 */
JNIEXPORT void Java_processing_hardware_arduino_cores_arduino_ArduinoImpl_delayMicroseconds
  (JNIEnv *, jclass, jint);

JNIEXPORT void Java_processing_hardware_arduino_cores_arduino_ArduinoImpl_delayMicroseconds
  (JNIEnv *env, jclass obj, jint arg1)
{
    // TODO: insert your code here
}

/*
 * Proprietary HaikuVM stack to JNI interface function.
 * DO NOT EDIT THIS FUNCTION – it is machine generated.
 * 
 * Class:     processing.hardware.arduino.cores.arduino.ArduinoImpl
 * Method:    delayMicroseconds
 * Signature: (I)V
 */
JNIEXPORT void native_processing_hardware_arduino_cores_arduino_ArduinoImpl_delayMicroseconds_IV(void) {
    pushTop();    // Save variable top onto stack.
    {
        jint    arg1 = pop()->i;
        jclass     obj = NULL;
        JNIEnv     *env = NULL; // not used in HaikuVM
        Java_processing_hardware_arduino_cores_arduino_ArduinoImpl_delayMicroseconds(env, obj, arg1);
    }
    popTop();
}

/////////////////////////////////////////////////


#ifdef __cplusplus
}
#endif
#endif

#endif
